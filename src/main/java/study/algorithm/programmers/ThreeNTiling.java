package study.algorithm.programmers;

/**
 * - 주의점
 * 블럭을 쪼개면서 나가면서 경우의 수를 산출해보자
 * n=2 크기인 블럭의 경우의수 * 나머지 블럭크기의 경우의수
 * n=4 크기의 블럭의 경우의수 * 나머지 블럭 크기의 경우의수
 * 와 같은 패턴이 나오긴 하지만 이 패턴을 이어나가다 보면 앞뒤만 바뀐 식이 나오는
 * 경우의 수가 나오게되는데 이러한 경우의 수들까지 모두 더하면 중복된 경우의 수가
 * 포함되는 것이다.
 *
 * - 풀이
 * n이 +2 될 때 마다 새로운 경우의수 2가지가 새로 나타나게 되는 문제이다.
 * 처음 2를 뺀 이전 크기의 경우의 수와 n=2인 크기의 블럭의 경우의수를 곱함
 * 위 주의사항인 중복된 경우의 수를 피해서 경우의수를 산출하려면
 * 각각 2씩 증가하면서 생겨난 새로운 경우의 수 2와 나머지 크기 블럭의 경우의수를 곱한
 * 값을 쭉 더하다 보면 패턴이 보이며, 즉 이것이 이 문제의 점화식이다
 */
public class ThreeNTiling {

  public int solution(int n) {
    if (n == 2) return 3;

    long[] dp = new long[n + 1];
    dp[2] = 3;
    dp[4] = 11;

    for (int x = 6; x <= n; x += 2) {
      long tmp = dp[x - 2] * 3;
      for (int y = x - 4; y >= 0; y -= 2) {
        tmp += dp[y] * 2;
      }
      dp[x] = tmp % 1_000_000_007;
    }

    return (int) dp[n];
  }

}
